// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: noble/forwarding/v1/events.proto

package types

import (
	fmt "fmt"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// AccountRegistered is emitted whenever a new forwarding account is registered.
type AccountRegistered struct {
	// address is the address of the forwarding account.
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// channel is the channel id that funds are forwarded through.
	Channel string `protobuf:"bytes,2,opt,name=channel,proto3" json:"channel,omitempty"`
	// recipient is the address of the recipient of forwards.
	Recipient string `protobuf:"bytes,3,opt,name=recipient,proto3" json:"recipient,omitempty"`
	// fallback is the address of the fallback account.
	Fallback string `protobuf:"bytes,4,opt,name=fallback,proto3" json:"fallback,omitempty"`
}

func (m *AccountRegistered) Reset()         { *m = AccountRegistered{} }
func (m *AccountRegistered) String() string { return proto.CompactTextString(m) }
func (*AccountRegistered) ProtoMessage()    {}
func (*AccountRegistered) Descriptor() ([]byte, []int) {
	return fileDescriptor_f58759da7cd78060, []int{0}
}
func (m *AccountRegistered) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccountRegistered) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccountRegistered.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccountRegistered) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccountRegistered.Merge(m, src)
}
func (m *AccountRegistered) XXX_Size() int {
	return m.Size()
}
func (m *AccountRegistered) XXX_DiscardUnknown() {
	xxx_messageInfo_AccountRegistered.DiscardUnknown(m)
}

var xxx_messageInfo_AccountRegistered proto.InternalMessageInfo

func (m *AccountRegistered) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *AccountRegistered) GetChannel() string {
	if m != nil {
		return m.Channel
	}
	return ""
}

func (m *AccountRegistered) GetRecipient() string {
	if m != nil {
		return m.Recipient
	}
	return ""
}

func (m *AccountRegistered) GetFallback() string {
	if m != nil {
		return m.Fallback
	}
	return ""
}

// AccountCleared is emitted whenever a forwarding account is cleared.
type AccountCleared struct {
	// address is the address of the forwarding account.
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// recipient is the address of the fallback account.
	Recipient string `protobuf:"bytes,2,opt,name=recipient,proto3" json:"recipient,omitempty"`
}

func (m *AccountCleared) Reset()         { *m = AccountCleared{} }
func (m *AccountCleared) String() string { return proto.CompactTextString(m) }
func (*AccountCleared) ProtoMessage()    {}
func (*AccountCleared) Descriptor() ([]byte, []int) {
	return fileDescriptor_f58759da7cd78060, []int{1}
}
func (m *AccountCleared) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccountCleared) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccountCleared.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccountCleared) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccountCleared.Merge(m, src)
}
func (m *AccountCleared) XXX_Size() int {
	return m.Size()
}
func (m *AccountCleared) XXX_DiscardUnknown() {
	xxx_messageInfo_AccountCleared.DiscardUnknown(m)
}

var xxx_messageInfo_AccountCleared proto.InternalMessageInfo

func (m *AccountCleared) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *AccountCleared) GetRecipient() string {
	if m != nil {
		return m.Recipient
	}
	return ""
}

// AllowedDenomsConfigured is emitted whenever the allowed denoms are updated.
type AllowedDenomsConfigured struct {
	// previous_denoms is the list of previously allowed denoms.
	PreviousDenoms []string `protobuf:"bytes,1,rep,name=previous_denoms,json=previousDenoms,proto3" json:"previous_denoms,omitempty"`
	// current_denoms is the list of currently allowed denoms.
	CurrentDenoms []string `protobuf:"bytes,2,rep,name=current_denoms,json=currentDenoms,proto3" json:"current_denoms,omitempty"`
}

func (m *AllowedDenomsConfigured) Reset()         { *m = AllowedDenomsConfigured{} }
func (m *AllowedDenomsConfigured) String() string { return proto.CompactTextString(m) }
func (*AllowedDenomsConfigured) ProtoMessage()    {}
func (*AllowedDenomsConfigured) Descriptor() ([]byte, []int) {
	return fileDescriptor_f58759da7cd78060, []int{2}
}
func (m *AllowedDenomsConfigured) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllowedDenomsConfigured) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AllowedDenomsConfigured.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AllowedDenomsConfigured) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllowedDenomsConfigured.Merge(m, src)
}
func (m *AllowedDenomsConfigured) XXX_Size() int {
	return m.Size()
}
func (m *AllowedDenomsConfigured) XXX_DiscardUnknown() {
	xxx_messageInfo_AllowedDenomsConfigured.DiscardUnknown(m)
}

var xxx_messageInfo_AllowedDenomsConfigured proto.InternalMessageInfo

func (m *AllowedDenomsConfigured) GetPreviousDenoms() []string {
	if m != nil {
		return m.PreviousDenoms
	}
	return nil
}

func (m *AllowedDenomsConfigured) GetCurrentDenoms() []string {
	if m != nil {
		return m.CurrentDenoms
	}
	return nil
}

func init() {
	proto.RegisterType((*AccountRegistered)(nil), "noble.forwarding.v1.AccountRegistered")
	proto.RegisterType((*AccountCleared)(nil), "noble.forwarding.v1.AccountCleared")
	proto.RegisterType((*AllowedDenomsConfigured)(nil), "noble.forwarding.v1.AllowedDenomsConfigured")
}

func init() { proto.RegisterFile("noble/forwarding/v1/events.proto", fileDescriptor_f58759da7cd78060) }

var fileDescriptor_f58759da7cd78060 = []byte{
	// 306 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x91, 0x41, 0x4a, 0x03, 0x31,
	0x14, 0x86, 0x9b, 0x56, 0xd4, 0x06, 0xac, 0x38, 0x2e, 0x0c, 0x22, 0xa1, 0x14, 0xc4, 0x82, 0x38,
	0x43, 0xf5, 0x04, 0xb5, 0x0a, 0xae, 0xbb, 0x74, 0x23, 0x99, 0xe4, 0x75, 0x1a, 0x4c, 0x93, 0x21,
	0xc9, 0x4c, 0x71, 0xe9, 0x0d, 0x3c, 0x96, 0xcb, 0x2e, 0x5d, 0x4a, 0x7b, 0x11, 0x69, 0x3a, 0x63,
	0xa9, 0x0b, 0x97, 0xef, 0xff, 0xbe, 0xe4, 0x0f, 0x79, 0xb8, 0xab, 0x4d, 0xaa, 0x20, 0x99, 0x18,
	0x3b, 0x67, 0x56, 0x48, 0x9d, 0x25, 0xe5, 0x20, 0x81, 0x12, 0xb4, 0x77, 0x71, 0x6e, 0x8d, 0x37,
	0xd1, 0x69, 0x30, 0xe2, 0xad, 0x11, 0x97, 0x83, 0xde, 0x3b, 0xc2, 0x27, 0x43, 0xce, 0x4d, 0xa1,
	0xfd, 0x18, 0x32, 0xe9, 0x3c, 0x58, 0x10, 0x11, 0xc1, 0x07, 0x4c, 0x08, 0x0b, 0xce, 0x11, 0xd4,
	0x45, 0xfd, 0xf6, 0xb8, 0x1e, 0xd7, 0x84, 0x4f, 0x99, 0xd6, 0xa0, 0x48, 0x73, 0x43, 0xaa, 0x31,
	0xba, 0xc0, 0x6d, 0x0b, 0x5c, 0xe6, 0x12, 0xb4, 0x27, 0xad, 0xc0, 0xb6, 0x41, 0x74, 0x8e, 0x0f,
	0x27, 0x4c, 0xa9, 0x94, 0xf1, 0x57, 0xb2, 0x17, 0xe0, 0xef, 0xdc, 0x7b, 0xc2, 0x9d, 0xea, 0x09,
	0x23, 0x05, 0xec, 0xff, 0xfe, 0x9d, 0x96, 0xe6, 0x9f, 0x96, 0x9e, 0xc4, 0x67, 0x43, 0xa5, 0xcc,
	0x1c, 0xc4, 0x03, 0x68, 0x33, 0x73, 0x23, 0xa3, 0x27, 0x32, 0x2b, 0xd6, 0x57, 0x5e, 0xe1, 0xe3,
	0xdc, 0x42, 0x29, 0x4d, 0xe1, 0x5e, 0x44, 0x80, 0x04, 0x75, 0x5b, 0xfd, 0xf6, 0xb8, 0x53, 0xc7,
	0x9b, 0x23, 0xd1, 0x25, 0xee, 0xf0, 0xc2, 0x5a, 0xd0, 0xbe, 0xf6, 0x9a, 0xc1, 0x3b, 0xaa, 0xd2,
	0x8d, 0x76, 0xff, 0xf8, 0xb9, 0xa4, 0x68, 0xb1, 0xa4, 0xe8, 0x7b, 0x49, 0xd1, 0xc7, 0x8a, 0x36,
	0x16, 0x2b, 0xda, 0xf8, 0x5a, 0xd1, 0xc6, 0xf3, 0x75, 0x26, 0xfd, 0xb4, 0x48, 0x63, 0x6e, 0x66,
	0x49, 0xf8, 0xf2, 0x1b, 0xe6, 0x1c, 0x78, 0xb7, 0xb3, 0x9b, 0xdb, 0xc4, 0xbf, 0xe5, 0xe0, 0xd2,
	0xfd, 0xb0, 0x9b, 0xbb, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x05, 0x3b, 0x20, 0xbe, 0xbf, 0x01,
	0x00, 0x00,
}

func (m *AccountRegistered) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccountRegistered) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccountRegistered) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Fallback) > 0 {
		i -= len(m.Fallback)
		copy(dAtA[i:], m.Fallback)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Fallback)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Recipient) > 0 {
		i -= len(m.Recipient)
		copy(dAtA[i:], m.Recipient)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Recipient)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Channel) > 0 {
		i -= len(m.Channel)
		copy(dAtA[i:], m.Channel)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Channel)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AccountCleared) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccountCleared) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccountCleared) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Recipient) > 0 {
		i -= len(m.Recipient)
		copy(dAtA[i:], m.Recipient)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Recipient)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AllowedDenomsConfigured) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllowedDenomsConfigured) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AllowedDenomsConfigured) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CurrentDenoms) > 0 {
		for iNdEx := len(m.CurrentDenoms) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.CurrentDenoms[iNdEx])
			copy(dAtA[i:], m.CurrentDenoms[iNdEx])
			i = encodeVarintEvents(dAtA, i, uint64(len(m.CurrentDenoms[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.PreviousDenoms) > 0 {
		for iNdEx := len(m.PreviousDenoms) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PreviousDenoms[iNdEx])
			copy(dAtA[i:], m.PreviousDenoms[iNdEx])
			i = encodeVarintEvents(dAtA, i, uint64(len(m.PreviousDenoms[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintEvents(dAtA []byte, offset int, v uint64) int {
	offset -= sovEvents(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AccountRegistered) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Channel)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Recipient)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Fallback)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *AccountCleared) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Recipient)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *AllowedDenomsConfigured) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PreviousDenoms) > 0 {
		for _, s := range m.PreviousDenoms {
			l = len(s)
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	if len(m.CurrentDenoms) > 0 {
		for _, s := range m.CurrentDenoms {
			l = len(s)
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	return n
}

func sovEvents(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozEvents(x uint64) (n int) {
	return sovEvents(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AccountRegistered) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccountRegistered: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccountRegistered: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recipient", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Recipient = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fallback", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fallback = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccountCleared) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccountCleared: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccountCleared: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recipient", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Recipient = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllowedDenomsConfigured) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllowedDenomsConfigured: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllowedDenomsConfigured: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousDenoms", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreviousDenoms = append(m.PreviousDenoms, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentDenoms", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CurrentDenoms = append(m.CurrentDenoms, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEvents(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthEvents
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupEvents
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthEvents
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthEvents        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEvents          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupEvents = fmt.Errorf("proto: unexpected end of group")
)
